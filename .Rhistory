nrow(residHMax)
dim(floodGrid)
floodGrid[1:10,]
length(lonVals)
length(unique(lon))
?unique
lon[1:10,]
lon[1:10]
floodGrid = matrix(c(lon, lat), ncol=2)
dim(floodGrid)
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
residMean = apply(residHMax, c(2, 3), mean)
quilt.plot(floodGrid, residMean)
residCntr = sweep(residMean, c(2, 3), residMean)
?sweep
residCntr = sweep(residHMax, c(2, 3), residMean)
quilt.plot(floodGrid, residCntr)
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
allHMaxMean = apply(allHMax, c(2, 3), mean)
allHMaxMean = apply(allHMax, c(2, 3), mean)
allHMaxCntr = sweep(alHMax, c(2, 3), allHMaxMean)
allHMaxCntr = sweep(allHMax, c(2, 3), allHMaxMean)
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMaxCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMaxCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
?fft
test = mvfft(residCntr[1,,])
names(test)
dim(test)
quilt.plot(floodGrid, test)
quilt.plot(floodGrid, c(test))
test[1:5, 1:5]
abs(test[1:5, 1:5])
quilt.plot(floodGrid, abs(c(test)))
for(i in 1:nrow(residHMax)) { #this is the best, but is the model to complex?
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMax[i,,]), main=paste0(i, "th Realization"))
}
quilt.plot(floodGrid, c(top), main="elevation")
for(i in 1:nrow(residHMax)) { #this is the best, but is the model to complex?
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) { # for non-complex models, this is the best
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
dim(normScores)
for(i in 1:nrow(residHMax)) { # for non-complex models, this is the best
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) { #this is the best, but is the model to complex?
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
quilt.plot(normScores[,1], normScores[,2], maxFlood, xlab="1st Eigenvector Score",
ylab="2nd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
quilt.plot(normScores[,1], normScores[,3], maxFlood, xlab="1st Eigenvector Score",
ylab="3rd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
quilt.plot(normScores[,2], normScores[,3], maxFlood, xlab="2nd Eigenvector Score",
ylab="3rd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
source('~/Desktop/d&d/roll.r')
r(2)
source('~/git/M9/loadTestData.r')
?boxplotVGram
library(fields)
?boxplotVGram
library("fields", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
exp(1)
exp(-1)
exp(-1.5)
.05/1.05
source('~/Desktop/test_mKrig_MLE_functions.R')
debugSource('~/git/fields/R/MLESpatialProcess.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
debugSource('~/git/fields/R/MLESpatialProcess.R')
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
names(out)
out$sigma.MLE.FULL
out$sigma.MLE
out$rho.MLE.FULL
source('~/Desktop/test_mKrig_MLE_functions.R')
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
m=20
vals = SigmaL %*% matrix(rnorm(n), nrow=n, ncol=m)
out = mKrig(points, vals, cov.function = "Exp.cov", theta=theta, lambda=lambda)
names(out)
out$lnProfileLike
out$lnProfileLike.FULL
quilt.plot(points)
quilt.plot(points, vals[,1])
quilt.plot(points, vals[,2])
quilt.plot(points, vals[,3])
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
View(MLESpatialProcess)
rm(list=list("MLESpatialProcess"))
rm("MLESpatialProcess")
source('~/Desktop/test_mKrig_MLE_functions.R')
debug(MLESpatialProcess)
source('~/Desktop/test_mKrig_MLE_functions.R')
dim(y)
names(opt)
opt$summary
theta.start
debug(mKrigMLEJoint)
opt = do.call("mKrigMLEJoint", c(list(x, y, lambda.guess = lambda.start,
cov.params.guess = list(theta = theta.start), cov.fun = cov.function,
cov.args = cov.args, optim.args = optim.args, verbose = verbose),
list(...)))
cov.params.guess
capture.evaluations
capture.evaluations
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
out$lnLik.eval
debug(mKrigMLEJoint)
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
debug(temp.fn)
names(hold)
dim(y)
hold$lnProfileLike
hold$lnProfileLike.FULL
mean(hold$lnProfileLike)
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
undebug(MLESpatialProcess)
undebug(mKrigMLEJoint)
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
100
source('~/Desktop/test_mKrig_MLE_functions.R')
500
source('~/Desktop/test_mKrig_MLE_functions.R')
exp(-1.5)
library(fields)
setwd("~/git/M9/")
source("taper.R")
source("okada.R")
source('predictions.R')
source('plotSubfault.R')
source('loadTestData.r')
source('fitModel.R')
source("loadFloodDat.R")
source("test.R")
source("exploratoryAnalysisFuns.R") # -418.9, 319
gpsPreds = predsGivenGPS(MLEs, 1000)
fullPreds = genFullPredsMVN(MLEs, 1000)
fullPreds10 = genFullPredsMVN(MLEs, 1000, 100) # add additional uncertainty to gps dat SD
# compute the conditional means (areal and pointwise)
gpsMucX = exp(gpsPreds$mucGPS+diag(gpsPreds$SigmaGPS)/2) * tvec
gpsMucB = gpsPreds$meanSlip
fullMucX = fullPreds$meanSlipGPS
fullMucB = fullPreds$meanSlip
fullMucX10 = fullPreds10$meanSlipGPS
fullMucB10 = fullPreds10$meanSlip
# compute the conditional SDs for the normals
gpsSDX = sqrt(diag(gpsPreds$SigmaGPS))
gpsSDB = sqrt(diag(gpsPreds$Sigma))
fullSDX = sqrt(diag(fullPreds$SigmaGPS))
fullSDB = sqrt(diag(fullPreds$Sigma))
fullSDX10 = sqrt(diag(fullPreds10$SigmaGPS))
fullSDB10 = sqrt(diag(fullPreds10$Sigma))
# compute the conditional SDs for the lognormal tapered slips (m is LN mean not N mean)
lnSD = function(m, s) { sqrt((exp(s^2)-1)*m^2) }
gpsSDX = lnSD(gpsMucX, gpsSDX) * tvecX
gpsSDB = lnSD(gpsMucB, gpsSDB) * tvecB
fullSDX = lnSD(fullMucX, fullSDX) * tvecX
fullSDB = lnSD(fullMucB, fullSDB) * tvecB
fullSDX10 = lnSD(fullMucX10, fullSDX10) * tvecX
fullSDB10 = lnSD(fullMucB10, fullSDB10) * tvecB
load("fixedFit_MVN.RData")
MLEs = fixedFitMVN$MLEs
# compute taper
tvec = taper(slipDatCSZ$Depth, lambda=MLEs[1])
tvecX = tvec
tvecB = taper(csz$depth, lambda=MLEs[1])
# get GPS data and CSZ prediction coordinates
xd = cbind(slipDatCSZ$lon, slipDatCSZ$lat)
xp = cbind(csz$longitude, csz$latitude)
# generate the predictions
gpsPreds = predsGivenGPS(MLEs, 1000)
fullPreds = genFullPredsMVN(MLEs, 1000)
fullPreds10 = genFullPredsMVN(MLEs, 1000, 100) # add additional uncertainty to gps dat SD
# compute the conditional means (areal and pointwise)
gpsMucX = exp(gpsPreds$mucGPS+diag(gpsPreds$SigmaGPS)/2) * tvec
gpsMucB = gpsPreds$meanSlip
fullMucX = fullPreds$meanSlipGPS
fullMucB = fullPreds$meanSlip
fullMucX10 = fullPreds10$meanSlipGPS
fullMucB10 = fullPreds10$meanSlip
# compute the conditional SDs for the normals
gpsSDX = sqrt(diag(gpsPreds$SigmaGPS))
gpsSDB = sqrt(diag(gpsPreds$Sigma))
fullSDX = sqrt(diag(fullPreds$SigmaGPS))
fullSDB = sqrt(diag(fullPreds$Sigma))
fullSDX10 = sqrt(diag(fullPreds10$SigmaGPS))
fullSDB10 = sqrt(diag(fullPreds10$Sigma))
# compute the conditional SDs for the lognormal tapered slips (m is LN mean not N mean)
lnSD = function(m, s) { sqrt((exp(s^2)-1)*m^2) }
gpsSDX = lnSD(gpsMucX, gpsSDX) * tvecX
gpsSDB = lnSD(gpsMucB, gpsSDB) * tvecB
fullSDX = lnSD(fullMucX, fullSDX) * tvecX
fullSDB = lnSD(fullMucB, fullSDB) * tvecB
fullSDX10 = lnSD(fullMucX10, fullSDX10) * tvecX
fullSDB10 = lnSD(fullMucB10, fullSDB10) * tvecB
gpsSubs = predsToSubsidence(MLEs, gpsPreds)
gpsSubs = predsToSubsidence(MLEs, gpsPreds, useMVNApprox = FALSE)
fullSubs = predsToSubsidence(MLEs, fullPreds, useMVNApprox = FALSE)
fullSubs10 = predsToSubsidence(MLEs, fullPreds10, useMVNApprox = FALSE)
comparePredsToSubs(MLEs, slipPreds=fullSlips, subPreds=fullSubs, nsim=1000,
plotNameRoot="full", savePlots=FALSE)
comparePredsToSubs(MLEs, slipPreds=fullPreds, subPreds=fullSubs, nsim=1000,
plotNameRoot="full", savePlots=FALSE)
dim(fullPreds$slipSims)
plotFault(csz, fullPreds$slipSims[,1])
plotFault(csz, fullPreds$slipSims[,2])
plotFault(csz, fullPreds$slipSims[,3])
plotFault(csz, fullPreds$slipSims[,4])
plotFault(csz, fullPreds$slipSims[,5])
plotFault(csz, fullPreds$slipSims[,6])
plotFault(csz, fullPreds$slipSims[,7])
plotFault(csz, fullPreds$slipSims[,8])
fullSubs = predsToSubsidence(MLEs, fullPreds, useMVNApprox = FALSE)
comparePredsToSubs(MLEs, slipPreds=fullPreds, subPreds=fullSubs, nsim=1000,
plotNameRoot="full", savePlots=FALSE)
comparePredsToSubs(MLEs, slipPreds=fullPreds10, subPreds=fullSubs10, nsim=1000,
plotNameRoot="full10", savePlots=FALSE)
plotFault(csz, fullPreds10$meanSlip)
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
points(dr1$Lon, dr1$Lat, cex=1, pch=3, col="red")
comparePredsToSubs(MLEs, slipPreds=gpsPreds, subPreds=gpsSubs, nsim=1000,
plotNameRoot="gps", savePlots=FALSE)
source('~/git/M9/predictions.R')
source('~/git/M9/predictions.R')
gpsPreds = predsGivenGPS(MLEs, 1000)
gpsMucX = exp(gpsPreds$mucGPS+diag(gpsPreds$SigmaGPS)/2) * tvec
gpsMucB = gpsPreds$meanSlip
fullMucX = fullPreds$meanSlipGPS
fullMucB = fullPreds$meanSlip
fullMucX10 = fullPreds10$meanSlipGPS
fullMucB10 = fullPreds10$meanSlip
# compute the conditional SDs for the normals
gpsSDX = sqrt(diag(gpsPreds$SigmaGPS))
gpsSDB = sqrt(diag(gpsPreds$Sigma))
fullSDX = sqrt(diag(fullPreds$SigmaGPS))
fullSDB = sqrt(diag(fullPreds$Sigma))
fullSDX10 = sqrt(diag(fullPreds10$SigmaGPS))
fullSDB10 = sqrt(diag(fullPreds10$Sigma))
# compute the conditional SDs for the lognormal tapered slips (m is LN mean not N mean)
lnSD = function(m, s) { sqrt((exp(s^2)-1)*m^2) }
gpsSDX = lnSD(gpsMucX, gpsSDX) * tvecX
gpsSDB = lnSD(gpsMucB, gpsSDB) * tvecB
fullSDX = lnSD(fullMucX, fullSDX) * tvecX
fullSDB = lnSD(fullMucB, fullSDB) * tvecB
fullSDX10 = lnSD(fullMucX10, fullSDX10) * tvecX
fullSDB10 = lnSD(fullMucB10, fullSDB10) * tvecB
gpsSubs = predsToSubsidence(MLEs, gpsPreds, useMVNApprox = FALSE)
comparePredsToSubs(MLEs, slipPreds=gpsPreds, subPreds=gpsSubs, nsim=1000,
plotNameRoot="gps", savePlots=FALSE)
gpsPreds = predsGivenGPS(MLEs, 1000)
source('~/git/M9/predictions.R')
fullPreds = genFullPredsMVN(MLEs, 1000)
fullPreds10 = genFullPredsMVN(MLEs, 1000, 100) # add additional uncertainty to gps dat SD
# compute the conditional means (areal and pointwise)
gpsMucX = exp(gpsPreds$mucGPS+diag(gpsPreds$SigmaGPS)/2) * tvec
gpsMucB = gpsPreds$meanSlip
fullMucX = fullPreds$meanSlipGPS
fullMucB = fullPreds$meanSlip
fullMucX10 = fullPreds10$meanSlipGPS
fullMucB10 = fullPreds10$meanSlip
# compute the conditional SDs for the normals
gpsSDX = sqrt(diag(gpsPreds$SigmaGPS))
gpsSDB = sqrt(diag(gpsPreds$Sigma))
fullSDX = sqrt(diag(fullPreds$SigmaGPS))
fullSDB = sqrt(diag(fullPreds$Sigma))
fullSDX10 = sqrt(diag(fullPreds10$SigmaGPS))
fullSDB10 = sqrt(diag(fullPreds10$Sigma))
# compute the conditional SDs for the lognormal tapered slips (m is LN mean not N mean)
lnSD = function(m, s) { sqrt((exp(s^2)-1)*m^2) }
gpsSDX = lnSD(gpsMucX, gpsSDX) * tvecX
gpsSDB = lnSD(gpsMucB, gpsSDB) * tvecB
fullSDX = lnSD(fullMucX, fullSDX) * tvecX
fullSDB = lnSD(fullMucB, fullSDB) * tvecB
fullSDX10 = lnSD(fullMucX10, fullSDX10) * tvecX
fullSDB10 = lnSD(fullMucB10, fullSDB10) * tvecB
gpsSubs = predsToSubsidence(MLEs, gpsPreds, useMVNApprox = FALSE)
fullSubs = predsToSubsidence(MLEs, fullPreds, useMVNApprox = FALSE)
fullSubs10 = predsToSubsidence(MLEs, fullPreds10, useMVNApprox = FALSE)
comparePredsToSubs(MLEs, slipPreds=gpsPreds, subPreds=gpsSubs, nsim=1000,
plotNameRoot="gpsSigmaPDeflate", savePlots=TRUE)
comparePredsToSubs(MLEs, slipPreds=fullPreds, subPreds=fullSubs, nsim=1000,
plotNameRoot="fullSigmaPDeflate", savePlots=TRUE)
comparePredsToSubs(MLEs, slipPreds=fullPreds10, subPreds=fullSubs10, nsim=1000,
plotNameRoot="full100SigmaPDeflate", savePlots=TRUE)
quilt.plot(xd, gpsMucX, main="GPS Mean")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, gpsSDX, main="GPS SD")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, fullMucX10, main="Full Mean")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, fullSDX10, main="Full SD")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, gpsMucX, main="GPS Mean")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, gpsSDX, main="GPS SD")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, fullMucX, main="Full Mean")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
quilt.plot(xd, fullSDX, main="Full SD")
map("world", "Canada", add=TRUE, lwd=1.5)
US(add=TRUE, lwd=1.5)
plotFault(faultGeom, plotData=FALSE, new=FALSE)
genFullPredsMVN = function(params, nsim=1000, sdAdd=0) {
# get fit MLEs
lambda = params[1]
muZeta = params[2]
sigmaZeta = params[3]
lambda0 = params[4]
muXi = params[5]
# set other relevant parameters
nuZeta = 3/2 # Matern smoothness
phiZeta = 232.5722 # fit from fitGPSCovariance()
# Calculate the standard error vector of xi. Derivation from week 08_30_17.Rmd presentation.
# Transformation from additive error to  multiplicative lognormal model with asympototic
# median and variance matching.
sigmaXi = sqrt(log(.5*(sqrt(4*(slipDatCSZ$slipErr+sdAdd)^2/slipDatCSZ$slip^2 + 1) + 1)))
# get data
logX = log(slipDatCSZ$slip)
Y = -dr1$subsidence
# get Okada linear transformation matrix
nx = 300
ny=  900
lonGrid = seq(lonRange[1], lonRange[2], l=nx)
latGrid = seq(latRange[1], latRange[2], l=ny)
G = okadaAll(csz, lonGrid, latGrid, cbind(dr1$Lon, dr1$Lat), slip=1, poisson=lambda0)
# get taper vector
tvec = taper(csz$depth, lambda=lambda)
# compute G %*% T
GT = sweep(G, 2, tvec, "*")
# get coordinates for GPS data
xs = cbind(slipDatCSZ$lon, slipDatCSZ$lat)
# compute relevant covariances
load("arealCSZCor.RData")
SigmaB = arealCSZCor * sigmaZeta^2
SigmaSB = pointArealZetaCov(params, xs, csz, nDown=9, nStrike=12)
SigmaS = stationary.cov(xs, Covariance="Matern", theta=phiZeta,
smoothness=nuZeta, Distance="rdist.earth",
Dist.args=list(miles=FALSE)) * sigmaZeta^2
SigmaYMod = diag(exp(muZeta + diag(SigmaB)/2)) %*% t(GT)
SigmaBY = SigmaB %*% SigmaYMod
SigmaSY = SigmaSB %*% SigmaYMod
subDistn = getSubsidenceVarianceMat(params, fault = csz, G = G)
SigmaY = subDistn$Sigma
# now block them into predictions and data covariance matrices
SigmaP = cbind(rbind(SigmaB, SigmaSB), rbind(t(SigmaSB), SigmaS))
SigmaD = cbind(rbind(SigmaS + diag(sigmaXi^2), t(SigmaSY)), rbind(SigmaSY, SigmaY))
SigmaPtoD = cbind(rbind(t(SigmaSB), SigmaS), rbind(SigmaBY, SigmaSY))
# get block means
muP = muZeta
muD = c(rep(muZeta + muXi, length(logX)), GT %*% exp(muZeta + diag(SigmaB)/2))
# compute conditional normal mean and standard error in mean estimate
Xd = c(logX, Y)
condDistn = conditionalNormal(Xd, muP, muD, SigmaP, SigmaD, SigmaPtoD)
muc = condDistn$muc
Sigmac = condDistn$Sigmac
##### now generate the conditional simulations.  Note that we still use the
##### marginal covariance structure, but we've conditionally updated the mean.
# get prediction locations
# get CSZ prediction coordinates
xd = cbind(slipDatCSZ$lon, slipDatCSZ$lat)  # d is GPS locations
xp = cbind(csz$longitude, csz$latitude) # p is fault areal locations
nd = nrow(xd)
np = nrow(xp)
areal = 1:np
point = (np+1):(np+nd)
# Cholesky decomp used for simulations (don't add Sigmac because that
# can lead to non-physical results.  Here we just treat the mean as
# constant and use the marginal variability)
# NOTE: deflate variance to account for increased variation due to
#       conditional mean (using MSE = Var + bias^2 formula)
# SigmaTot = SigmaP + Sigmac
varDeflation = 1 - mean((muc[point] - muZeta)^2)/sigmaZeta^2
SigmaTot = SigmaP * varDeflation
# SigmaTot = SigmaP
SigmaL = t(chol(SigmaTot))
# generate predictive simulations
zSims = matrix(rnorm(nsim*(nrow(xp)+nrow(xd))), nrow=nrow(xp)+nrow(xd), ncol=nsim)
logZetaSims0 = SigmaL %*% zSims + muZeta # each column is a zero mean simulation
logZetaSims = sweep(logZetaSims0, 1, muc, "+") # add conditional mean to simulations
zetaSims = exp(logZetaSims)
tvec = taper(c(csz$depth, slipDatCSZ$Depth), lambda = lambda)
slipSims = sweep(zetaSims, 1, tvec, FUN="*")
# seperate areal average sims from GPS point location sims
slipSimsGPS = slipSims[point,]
slipSims = slipSims[areal,]
# get mean slip prediction field
meanSlip = exp(muc[areal] + diag(SigmaTot[areal,areal])/2) * tvec[areal]
meanSlipGPS = exp(muc[point] + diag(SigmaTot[point,point])/2) * tvec[point]
return(list(meanSlip=meanSlip, meanSlipGPS=meanSlipGPS, slipSims=slipSims, slipSimsGPS=slipSimsGPS,
Sigmac=Sigmac[areal, areal], muc=muc[areal], SigmacGPS = Sigmac[point, point],
mucGPS=muc[point], Sigma=SigmaTot[areal,areal], SigmaGPS=SigmaTot[point,point]))
}
gpsPreds = predsGivenGPS(MLEs, 1000)
gpsMucX = exp(gpsPreds$mucGPS+diag(gpsPreds$SigmaGPS)/2) * tvec
gpsMucB = gpsPreds$meanSlip
fullMucX = fullPreds$meanSlipGPS
fullMucB = fullPreds$meanSlip
fullMucX10 = fullPreds10$meanSlipGPS
fullMucB10 = fullPreds10$meanSlip
# compute the conditional SDs for the normals
gpsSDX = sqrt(diag(gpsPreds$SigmaGPS))
gpsSDB = sqrt(diag(gpsPreds$Sigma))
fullSDX = sqrt(diag(fullPreds$SigmaGPS))
fullSDB = sqrt(diag(fullPreds$Sigma))
fullSDX10 = sqrt(diag(fullPreds10$SigmaGPS))
fullSDB10 = sqrt(diag(fullPreds10$Sigma))
# compute the conditional SDs for the lognormal tapered slips (m is LN mean not N mean)
lnSD = function(m, s) { sqrt((exp(s^2)-1)*m^2) }
gpsSDX = lnSD(gpsMucX, gpsSDX) * tvecX
gpsSDB = lnSD(gpsMucB, gpsSDB) * tvecB
fullSDX = lnSD(fullMucX, fullSDX) * tvecX
fullSDB = lnSD(fullMucB, fullSDB) * tvecB
fullSDX10 = lnSD(fullMucX10, fullSDX10) * tvecX
fullSDB10 = lnSD(fullMucB10, fullSDB10) * tvecB
gpsSubs = predsToSubsidence(MLEs, gpsPreds, useMVNApprox = FALSE)
comparePredsToSubs(MLEs, slipPreds=gpsPreds, subPreds=gpsSubs, nsim=1000,
plotNameRoot="gpsSigmaPDeflate", savePlots=TRUE)
source('~/git/M9/predictions.R')
source('~/git/M9/predictions.R')
gpsPreds = predsGivenGPS(MLEs, 1000)
fullPreds = genFullPredsMVN(MLEs, 1000)
fullPreds10 = genFullPredsMVN(MLEs, 1000, 100) # add additional uncertainty to gps dat SD
# compute the conditional means (areal and pointwise)
gpsMucX = exp(gpsPreds$mucGPS+diag(gpsPreds$SigmaGPS)/2) * tvec
gpsMucB = gpsPreds$meanSlip
fullMucX = fullPreds$meanSlipGPS
fullMucB = fullPreds$meanSlip
fullMucX10 = fullPreds10$meanSlipGPS
fullMucB10 = fullPreds10$meanSlip
# compute the conditional SDs for the normals
gpsSDX = sqrt(diag(gpsPreds$SigmaGPS))
gpsSDB = sqrt(diag(gpsPreds$Sigma))
fullSDX = sqrt(diag(fullPreds$SigmaGPS))
fullSDB = sqrt(diag(fullPreds$Sigma))
fullSDX10 = sqrt(diag(fullPreds10$SigmaGPS))
fullSDB10 = sqrt(diag(fullPreds10$Sigma))
# compute the conditional SDs for the lognormal tapered slips (m is LN mean not N mean)
lnSD = function(m, s) { sqrt((exp(s^2)-1)*m^2) }
gpsSDX = lnSD(gpsMucX, gpsSDX) * tvecX
gpsSDB = lnSD(gpsMucB, gpsSDB) * tvecB
fullSDX = lnSD(fullMucX, fullSDX) * tvecX
fullSDB = lnSD(fullMucB, fullSDB) * tvecB
fullSDX10 = lnSD(fullMucX10, fullSDX10) * tvecX
fullSDB10 = lnSD(fullMucB10, fullSDB10) * tvecB
gpsSubs = predsToSubsidence(MLEs, gpsPreds, useMVNApprox = FALSE)
fullSubs = predsToSubsidence(MLEs, fullPreds, useMVNApprox = FALSE)
fullSubs10 = predsToSubsidence(MLEs, fullPreds10, useMVNApprox = FALSE)
comparePredsToSubs(MLEs, slipPreds=gpsPreds, subPreds=gpsSubs, nsim=1000,
plotNameRoot="gpsSigmac", savePlots=TRUE)
comparePredsToSubs(MLEs, slipPreds=fullPreds, subPreds=fullSubs, nsim=1000,
plotNameRoot="fullSigmac", savePlots=TRUE)
comparePredsToSubs(MLEs, slipPreds=fullPreds10, subPreds=fullSubs10, nsim=1000,
plotNameRoot="full100Sigmac", savePlots=TRUE)
source('~/git/M9/predictions.R')
testNormality(MLEs, CSZ)
testNormality(MLEs, csz)
dim(GT)
length(meanVec)
muZeta
sigmaZeta
dim(SigmaZeta)
length(SigmaZeta)
source('~/git/M9/predictions.R')
testNormality(MLEs, csz)
source('~/git/M9/test.R')
testNormality(MLEs, csz)
