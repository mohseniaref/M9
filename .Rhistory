"CSZR_M1.tt3", "CSZR_SM1.tt3", "CSZ_SS3_Defm_FINAL.tt3")
#NOTE: CSZ_SS3_Defm_FINAL.tt3 has slightly different dx, dy, dt.
#Instead of 0.0166, 0.0166, and 0.5, it's 0.0167, 0.0167, and 1
#respectively
for(f in 1:length(files)) {
if(f == 1) {
out = loadTopo(files[f])
out$dat = out$dat[,,out$mt]
}
else {
#concatenate data in out list:
tmp = loadTopo(files[f])
out$dat = abind(out$dat, tmp$dat[,,tmp$mt], along=3)
out$mx = c(out$mx, tmp$mx)
out$my = c(out$my, tmp$my)
out$mt = c(out$mt, tmp$mt)
out$xlower = c(out$xlower, tmp$xlower)
out$ylower = c(out$ylower, tmp$ylower)
out$t0 = c(out$t0, tmp$t0)
out$dx = c(out$dx, tmp$dx)
out$dy = c(out$dy, tmp$dy)
out$dt = c(out$dt, tmp$dt)
}
}
#set wd back to what it was before
setwd(wd)
return(out)
}
loadAllDeformations = function() {
wd = getwd()
setwd("~/git/M9/CSZR")
#topography data files
files = system("ls *.tt3", intern=TRUE)
#NOTE: CSZ_SS3_Defm_FINAL.tt3 has slightly different dx, dy, dt.
#Instead of 0.0166, 0.0166, and 0.5, it's 0.0167, 0.0167, and 1
#respectively
for(f in 1:length(files)) {
if(f == 1) {
out = loadTopo(files[f])
out$dat = out$dat[,,out$mt]
}
else {
#concatenate data in out list:
tmp = loadTopo(files[f])
out$dat = abind(out$dat, tmp$dat[,,tmp$mt], along=3)
out$mx = c(out$mx, tmp$mx)
out$my = c(out$my, tmp$my)
out$mt = c(out$mt, tmp$mt)
out$xlower = c(out$xlower, tmp$xlower)
out$ylower = c(out$ylower, tmp$ylower)
out$t0 = c(out$t0, tmp$t0)
out$dx = c(out$dx, tmp$dx)
out$dy = c(out$dy, tmp$dy)
out$dt = c(out$dt, tmp$dt)
}
}
#set wd back to what it was before
setwd(wd)
return(out)
}
library(rARPACK)
defDat = loadAllDeformations()
dat = matrix(nrow=dim(defDat$dat)[3], ncol=dim(defDat$dat)[1]*dim(defDat$dat)[2])
for(i in 1:dim(defDat$dat)[3]) {
dat[i,] = c(defDat$dat[,,i])
}
grid = make.surface.grid(list(x=1:dim(defDat$dat)[1], y=1:dim(defDat$dat)[2]))
for(i in 1:nrow(dat)) {
quilt.plot(grid, c(dat[i,]), main=paste0(i, "th Realization"))
}
names(defDat)
defDat$ylower
dim(dat)
truncation = 19
out = svds(dat, k=truncation)
plot(out$d)
mu = colMeans(dat)
datCntr = sweep(dat, 2, mu)
out = svds(datCntr, k=truncation)
plot(out$d)
totalVar = norm(datCntr, type="F")^2
totalVar
plot(cumsum(out$d^2)/totalVar)
cumsum(out$d^2)/totalVar
dim(out$u)
scores = out$u %*% diag(out$d)
scores
dim(scores)
wd = getwd()
library(RcppCNPy)
library(fields)
library(abind)
#####get SageMathCloud testing data:
setwd("~/git/M9/test_data")
#allHMax
allHMax = array(NA, dim=c(6, 250, 250))
for(i in 0:5) {
fname = paste0("allHMax", i, ".npy")
tmp = npyLoad(fname)
allHMax[i+1, , ] = tmp
}
#topography/bathymetry, lon, lat
topo = npyLoad("CCTopo.npy")
lon = npyLoad("CCLon.npy")
lat = npyLoad("CCLat.npy")
setwd(wd)
source('~/git/M9/loadTestData.r')
defDat = loadAllDeformations()
defDat$files
source('~/git/M9/loadTestData.r')
defDat = loadAllDeformations()
defDat$files
source('~/git/M9/loadTestData.r')
defDat = loadAllDeformations()
out$files
defDat$files
defDat$files[c(1, 4, 7, 10, 12, 15, 19)]
defDat$files[c(1, 4, 7, 12, 15, 19)]
scores
testI = c(1, 4, 7, 12, 15, 19)
testScores = scores[testI,]
testScores
plot(1:length(out$d), out$d^2, pch=19, col="blue",
main="Deformation Variance Explained", xlab="", ylab="Singular Value")
cumVarExp = cumsum(out$d^2)
plot(1:length(out$d), cumVarExp/sum(out$d^2), pch=19, col="blue", ylim=c(0, 1),
main="Percent of Total Deformation Variance Explained", xlab="",
ylab="Singular Value")
plot(1:length(out$d), cumVarExp/sum(out$d^2), pch=19, col="blue", ylim=c(0, 1),
main="Fraction of Total Deformation Variance Explained", xlab="",
ylab="Cumulative Variance Explained (Frac)")
plot(1:length(out$d), cumVarExp/sum(out$d^2), pch=19, col="blue", ylim=c(0, 1),
main="Fraction of Total Deformation Variance Explained", xlab="",
ylab="Fraction Variance Explained")
plot(1:length(out$d), cumVarExp/sum(out$d^2), pch=19, col="blue", ylim=c(0, 1),
main="Cumulative Fraction Variance Explained", xlab="",
ylab="Variance Explained")
dim(grid)
for(i in 1:length(out$d)) {
quilt.plot(grid, c(out$v[,i]), main=paste0(i, "th Eigenmode"))
}
plot(cumsum(d^2)/sum(d^2), xlab="Principal Component", ylab="Variance Explained (Fraction)",
main="Cumulative Fraction of Variance Explained", pch=19, col="blue")
plot(cumsum(out$d^2)/sum(out$d^2), xlab="Principal Component", ylab="Variance Explained (Fraction)",
main="Cumulative Fraction of Variance Explained", pch=19, col="blue")
plot(cumsum(out$d^2)/sum(out$d^2), xlab="Eigenvector", ylab="Variance Explained (Fraction)",
main="Cumulative Fraction of Variance Explained", pch=19, col="blue")
cumsum(out$d^2)/sum(out$d^2)
truncation = 3 #eigenmodes 1-9 appear to have little noise, first 3 capture almost 98% of variation
testScores = scores[testI, 1:truncation]
testScores
characteristicScores = sweep(testScores, 2, sd)
charScores = sweep(testScores, 2, sd)
testScores
?sweep
charScores = apply(testScores, 2, sd) #chacteristic scores
charScores
normScores = sweep(testScores, 2, charScores, fun="/")
normScores = sweep(testScores, 2, 1/charScores, fun="*")
normScores = sweep(testScores, 2, 1/charScores, FUN="*")
normScores
charScores
testScores
scoreMean = apply(testScores, 2, mean) #chacteristic scores
scoreSD = apply(testScores, 2, sd) #chacteristic scores
normScores = sweep(testScores, 2, scoreMean)
normScores = sweep(normScores, 2, 1/scoreSD, FUN="*")
normScores
floodDat = loadFloodData()
allHMax = floodDat$allHMax
dim(allHMax)
maxFlood = apply(allHMax, 1, max)
dim(maxFlood)
length(maxFlood)
maxFlood
testScores
quilt.plot(normScores[,1], normScores[,2], maxFlood, main="x:1, y:2")
quilt.plot(normScores[,1], normScores[,3], maxFlood, main="x:1, y:3")
quilt.plot(normScores[,2], normScores[,3], maxFlood, main="x:2, y:3")
quilt.plot(normScores[,1], normScores[,2], maxFlood, main="x:1, y:2", nx=20, ny=20)
quilt.plot(normScores[,1], normScores[,3], maxFlood, main="x:1, y:3", nx=20, ny=20)
quilt.plot(normScores[,2], normScores[,3], maxFlood, main="x:2, y:3", nx=20, ny=20)
out$d^2
normScores = sweep(testScores, 2, scoreMean)
normScores = normScores*(1/sd(normScores))
normScores
normScores = sweep(testScores, 2, scoreMean)
normScores = normScores*(1/scoreSD)
normScores
scoreSD = sd(testScores) #chacteristic scores
normScores = sweep(testScores, 2, scoreMean)
normScores = normScores*(1/scoreSD)
normScores
normScores = sweep(testScores, 2, scoreMean)
normScores*(1/scoreSD)
normScores*(1/sd(normScores))
scoreMean = apply(testScores, 2, mean) #chacteristic scores
normScores = sweep(testScores, 2, scoreMean)
scoreSD = sd(normScores) #chacteristic scores
normScores = normScores*(1/scoreSD)
normScores
quilt.plot(normScores[,1], normScores[,2], maxFlood, main="x:1, y:2", nx=20, ny=20)
quilt.plot(normScores[,1], normScores[,3], maxFlood, main="x:1, y:3", nx=20, ny=20)
quilt.plot(normScores[,2], normScores[,3], maxFlood, main="x:2, y:3", nx=20, ny=20)
quilt.plot(normScores[,1], normScores[,2], maxFlood, xlim="1st Eigenvector Score",
ylim="2nd Eigenvector Score", nx=20, ny=20)
b="1st Eigenvector Score",
ylab="2nd Eigenvector Score", nx=20, ny=20)
quilt.plot(normScores[,1], normScores[,2], maxFlood, xlab="1st Eigenvector Score",
ylab="2nd Eigenvector Score", nx=20, ny=20)
quilt.plot(normScores[,1], normScores[,2], maxFlood, xlab="1st Eigenvector Score",
ylab="2nd Eigenvector Score", nx=20, ny=20, main="Max Flood Level")
quilt.plot(normScores[,1], normScores[,2], maxFlood, xlab="1st Eigenvector Score",
ylab="2nd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
quilt.plot(normScores[,1], normScores[,3], maxFlood, xlab="1st Eigenvector Score",
ylab="3rd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
quilt.plot(normScores[,2], normScores[,3], maxFlood, xlab="2nd Eigenvector Score",
ylab="3rd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)"
)
?OPE
library(OEP)
library(OPE)
?OPE
dim(top)
dim(floodDat$top)
top = floodDat$topo
lon = floodDat$lon
lat = floodDat$lat
range(long)
range(lon)
dim(lon)
lonVals = sort(unique(lon))
latVals = sort(unique(lat))
floodGrid = grid(lon=lonVals, lat=latVals)
floodGrid = grid(list(lon=lonVals, lat=latVals))
floodGrid = make.surface.grid(list(lon=lonVals, lat=latVals))
for(i in 1:nrow(dat)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
residHMax = allHMax
for(i in 1:dim(allHMax)[1]) {
floodVals = allHMax[i,,]
model = lm(c(floodVals) ~ c(top))
residVals = residuals(model)
residHMax[i,,] = array(c(residVals), dim=c(1,nX,nY))
}
ion from allHMax
nX = dim(allHMax)[2]
nY = dim(allHMax)[3]
residHMax = allHMax
for(i in 1:dim(allHMax)[1]) {
floodVals = allHMax[i,,]
model = lm(c(floodVals) ~ c(top))
residVals = residuals(model)
residHMax[i,,] = array(c(residVals), dim=c(1,nX,nY))
}
for(i in 1:nrow(dat)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
dim(residHMax)
nrow(residHMax)
dim(floodGrid)
floodGrid[1:10,]
length(lonVals)
length(unique(lon))
?unique
lon[1:10,]
lon[1:10]
floodGrid = matrix(c(lon, lat), ncol=2)
dim(floodGrid)
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
residMean = apply(residHMax, c(2, 3), mean)
quilt.plot(floodGrid, residMean)
residCntr = sweep(residMean, c(2, 3), residMean)
?sweep
residCntr = sweep(residHMax, c(2, 3), residMean)
quilt.plot(floodGrid, residCntr)
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
allHMaxMean = apply(allHMax, c(2, 3), mean)
allHMaxMean = apply(allHMax, c(2, 3), mean)
allHMaxCntr = sweep(alHMax, c(2, 3), allHMaxMean)
allHMaxCntr = sweep(allHMax, c(2, 3), allHMaxMean)
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMaxCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMaxCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
?fft
test = mvfft(residCntr[1,,])
names(test)
dim(test)
quilt.plot(floodGrid, test)
quilt.plot(floodGrid, c(test))
test[1:5, 1:5]
abs(test[1:5, 1:5])
quilt.plot(floodGrid, abs(c(test)))
for(i in 1:nrow(residHMax)) { #this is the best, but is the model to complex?
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) {
quilt.plot(floodGrid, c(allHMax[i,,]), main=paste0(i, "th Realization"))
}
quilt.plot(floodGrid, c(top), main="elevation")
for(i in 1:nrow(residHMax)) { #this is the best, but is the model to complex?
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) { # for non-complex models, this is the best
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
dim(normScores)
for(i in 1:nrow(residHMax)) { # for non-complex models, this is the best
quilt.plot(floodGrid, c(residHMax[i,,]), main=paste0(i, "th Realization"))
}
for(i in 1:nrow(residHMax)) { #this is the best, but is the model to complex?
quilt.plot(floodGrid, c(residCntr[i,,]), main=paste0(i, "th Realization"))
}
quilt.plot(normScores[,1], normScores[,2], maxFlood, xlab="1st Eigenvector Score",
ylab="2nd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
quilt.plot(normScores[,1], normScores[,3], maxFlood, xlab="1st Eigenvector Score",
ylab="3rd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
quilt.plot(normScores[,2], normScores[,3], maxFlood, xlab="2nd Eigenvector Score",
ylab="3rd Eigenvector Score", nx=20, ny=20, main="Max Flood Level (m)")
source('~/Desktop/d&d/roll.r')
r(2)
source('~/git/M9/loadTestData.r')
?boxplotVGram
library(fields)
?boxplotVGram
library("fields", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
exp(1)
exp(-1)
exp(-1.5)
.05/1.05
source('~/Desktop/test_mKrig_MLE_functions.R')
debugSource('~/git/fields/R/MLESpatialProcess.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
debugSource('~/git/fields/R/MLESpatialProcess.R')
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
names(out)
out$sigma.MLE.FULL
out$sigma.MLE
out$rho.MLE.FULL
source('~/Desktop/test_mKrig_MLE_functions.R')
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
m=20
vals = SigmaL %*% matrix(rnorm(n), nrow=n, ncol=m)
out = mKrig(points, vals, cov.function = "Exp.cov", theta=theta, lambda=lambda)
names(out)
out$lnProfileLike
out$lnProfileLike.FULL
quilt.plot(points)
quilt.plot(points, vals[,1])
quilt.plot(points, vals[,2])
quilt.plot(points, vals[,3])
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
View(MLESpatialProcess)
rm(list=list("MLESpatialProcess"))
rm("MLESpatialProcess")
source('~/Desktop/test_mKrig_MLE_functions.R')
debug(MLESpatialProcess)
source('~/Desktop/test_mKrig_MLE_functions.R')
dim(y)
names(opt)
opt$summary
theta.start
debug(mKrigMLEJoint)
opt = do.call("mKrigMLEJoint", c(list(x, y, lambda.guess = lambda.start,
cov.params.guess = list(theta = theta.start), cov.fun = cov.function,
cov.args = cov.args, optim.args = optim.args, verbose = verbose),
list(...)))
cov.params.guess
capture.evaluations
capture.evaluations
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
out$lnLik.eval
debug(mKrigMLEJoint)
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
debug(temp.fn)
names(hold)
dim(y)
hold$lnProfileLike
hold$lnProfileLike.FULL
mean(hold$lnProfileLike)
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
undebug(MLESpatialProcess)
undebug(mKrigMLEJoint)
debugSource('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
source('~/Desktop/test_mKrig_MLE_functions.R')
100
source('~/Desktop/test_mKrig_MLE_functions.R')
500
source('~/Desktop/test_mKrig_MLE_functions.R')
exp(-1.5)
h = function(x) {ifelse(x >= 2, 1, 0)}
h = function(x) {x >= 2}
pnorm(2)
1-pnorm(2)
p=1-pnorm(2)
g = function(x) {dnorm(x, 3, 1)}
f = function(x) {dnorm{x, 0, 1}}
f = function(x) {dnorm(x, 0, 1)}
integrand = function(x) {f(x)^2/g(x)}
integrand(1)
integrand(2)
integrand(3)
integrand(0)
dnorm(0)
integrate(integrand, lower=2, upper=Inf)
integrate(integrand, lower=2, upper=10000)
?integrate
integrand(10)
integrand(100)
integrand = function(x) {ifelse(!is.nan(f(x)^2/g(x)), f(x)^2/g(x), 0)}
integrate(integrand, lower=2, upper=Inf)
integrate(integrand, lower=2, upper=Inf) - 1
names(integrate(integrand, lower=2, upper=Inf))
integrate(integrand, lower=2, upper=Inf)$value - 1
integrate(integrand, lower=2, upper=Inf)$value - p^2
(integrate(integrand, lower=2, upper=Inf)$value - p^2)/100
p^2
library(fields)
library(rstan)
setwd("~/git/M9/")
source("taper.R")
source("okada.R")
source('predictions.R')
source('plotSubfault.R')
source('loadTestData.r')
source('fitModel.R')
source("loadFloodDat.R")
source("test.R")
source("exploratoryAnalysisFuns.R") # -418.9, 319
debugSource('~/git/M9/fitModel.R')
load("fixedFit_MVN.RData")
MLEs = fixedFitMVN$MLEs
system.time(test <- fitModelIterative(maxIter=2, niterMCMC=250))
debugSource('~/git/M9/fitModel.R')
debugSource('~/git/M9/fitModel.R')
system.time(test <- fitModelIterative(maxIter=2, niterMCMC=250))
muZetaMLE
is.null(muVec)
debugSource('~/git/M9/fitModel.R')
system.time(test <- fitModelIterative(maxIter=2, niterMCMC=250))
muXiMLE
muZetaMLE
newPar
parMat
get("parMat", envir=env)
debugSource('~/git/M9/fitModel.R')
system.time(test <- fitModelIterative(maxIter=2, niterMCMC=250))
debugSource('~/git/M9/fitModel.R')
system.time(test <- fitModelIterative(maxIter=2, niterMCMC=250))
muXiMLE
currIter
params
plotFault(csz, muVec)
nrow(slipDatCSZ)
length(muVec)
plotFault(csz, muVec[631:871])
plotFault(csz, muVec[631:871])
plotFault(csz, muVec[631:871])
plotFault(csz, muVec[632:871])
testInputs <<- list(params=params, nsim=nsim, useMVNApprox=useMVNApprox, gpsDat=gpsDat, corMatGPS=corMatGPS, muVec=muVec)
debugSource('~/git/M9/fitModel.R')
names(testInputs)
parFit = doFixedFit(testInputs[[1]], testInputs[[2]], testInputs[[3]], testInputs[[4]], testInputs[[5]], testInputs[[6]])
muXiMLE
length(logX)
length(muZetaMLE)
debugSource('~/git/M9/fitModel.R')
parFit = doFixedFit(testInputs[[1]], testInputs[[2]], testInputs[[3]], testInputs[[4]], testInputs[[5]], testInputs[[6]])
muXiMLE
MLEs
sigmaZetaMLE
c(opt$par, 0.25, muXiMLE)
opt$par
initParams
debugSource('~/git/M9/fitModel.R')
parFit = doFixedFit(testInputs[[1]], testInputs[[2]], testInputs[[3]], testInputs[[4]], testInputs[[5]], testInputs[[6]])
debugSource('~/git/M9/fitModel.R')
parFit = doFixedFit(testInputs[[1]], testInputs[[2]], testInputs[[3]], testInputs[[4]], testInputs[[5]], testInputs[[6]])
initParams
opt$par
testInputs[[1]]
debugSource('~/git/M9/fitModel.R')
debugSource('~/git/M9/fitModel.R')
save(testInputs, file="testInputs.RData")
